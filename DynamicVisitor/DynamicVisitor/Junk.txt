#if false
        public class Rule {
            bool m_enumerable;
            bool m_name;

            public bool IsEnumerable
            {
                get
                {
                    return m_enumerable;
                }
            }

            public Object Next()
            {
                return null;
            }

            public string Name
            {
                get
                {
                    return m_name;
                }
            }
        }

        public static void accept(Rule rule, Object visitor)
        {
            Type visitor_type = visitor.GetType();

            {
                MethodInfo mi = visitor_type.GetMethod("visit", no_params);

                if (mi != null) mi.Invoke(visitor, no_args);
            }

            if (rule.IsEnumerable) {
                for (Rule new_rule = rule.Next(); new_rule != null; new_rule = rule.Next()) {
                    string visit_method = "visit_" + rule.Name;

                    MethodInfo mi = visitor_type.GetMethod(visit_method, no_params);

                    if (mi != null) {
                        Object new_visitor = mi.Invoke(visitor, no_args);
                        accept(new_rule, new_visitor);
                    }
                }
            } else {
                for (Rule p = rule.NextProp(); p != null; p = rule.NextProp()) {
                    string visit_method = "visit_" + p.Name;

                    if (p.IsTerminal) {
                        MethodInfo mi = visitor_type.GetMethod(visit_method, p.Types);

                        if (mi != null) {
                            mi.Invoke(visitor, client.GetArgs());
                        }
                    } else {
                        MethodInfo mi = visitor_type.GetMethod(visit_method, no_params);

                        if (mi != null) {
                            Object new_visitor = mi.Invoke(visitor, no_args);
                            accept(p, new_visitor);
                        }
                    }
                }
            }

            {
                MethodInfo mi = visitor_type.GetMethod("visit_End", no_params);

                if (mi != null) mi.Invoke(visitor, no_args);
            }
        }
#endif





            } else if ('+' == cin || '-' == cin) {
                // a num or id, cannot tell yet

                StringBuilder sb = new StringBuilder();
                sb.Append(cin);

                while (!is_eof || !is_delimiter(peek)) {
                    sb.Append(getc());
                }

                string tok = sb.ToString();

                if (is_valid_number(tok)) {
                    return Token.NUM;
                } else if (is_valid_id(tok)) {
                    return Token.VAR;
                } else {
                    return Token.ERROR;
                }
            } else if (is_initial(cin)) {
                // definitely an id

                StringBuilder sb = new StringBuilder(cin);

                while (is_subsequent(peek)) {
                    sb.Append(getc());
                }

                string id = sb.ToString();

                if ("quote" == id) {
                    return Token.KW_QUOTE;
                } else if ("lambda" == id) {
                    return Token.KW_LAMBDA;
                } else if ("if" == id) {
                    return Token.KW_IF;
                } else if ("set!" == id) {
                    return Token.KW_SET;
                } else if ("begin" == id) {
                    return Token.KW_BEGIN;
                } else if ("cond" == id) {
                    return Token.KW_COND;
                } else if ("and" == id) {
                    return Token.KW_AND;
                } else if ("or" == id) {
                    return Token.KW_OR;
                } else if ("case" == id) {
                    return Token.KW_CASE;
                } else if ("let" == id) {
                    return Token.KW_LET;
                } else if ("let*" == id) {
                    return Token.KW_LET_STAR;
                } else if ("letrec" == id) {
                    return Token.KW_LETREC;
                } else if ("do" == id) {
                    return Token.KW_DO;
                } else if ("delay" == id) {
                    return Token.KW_DELAY;
                } else if ("quasiquote" == id) {
                    return Token.KW_QUASIQUOTE;
                } else if ("else" == id) {
                    return Token.KW_ELSE;
                } else if ("=>" == id) {
                    return Token.KW_GOES_TO;
                } else if ("define" == id) {
                    return Token.KW_DEFINE;
                } else if ("unquote" == id) {
                    return Token.KW_UNQUOTE;
                } else if ("unquote-splicing" == id) {
                    return Token.KW_UNQUOTE_SPLICING;
                } else {
                    return Token.VAR;
                }
            } else if (
                char.IsDigit(cin) ||
                ('#' == cin && (
                    'b' == m_reader.peek() || 'B' == m_reader.peek() ||
                    'e' == m_reader.peek() || 'E' == m_reader.peek() ||
                    'i' == m_reader.peek() || 'I' == m_reader.peek() ||
                    'd' == m_reader.peek() || 'D' == m_reader.peek() ||
                    'o' == m_reader.peek() || 'O' == m_reader.peek() ||
                    'x' == m_reader.peek() || 'X' == m_reader.peek()))) {

                StringBuilder sb;

                sb.Append(char.ConvertFromUtf32(cin));
                sb.Append(char.ConvertFromUtf32(m_reader.getc()));

                while (!is_eof || !is_delimiter(peek)) {
                    sb.Append(getc());
                }

                return Token.NUM;
            } else if ('#' == cin && '(' == m_reader.peek()) {
                m_reader.getc();
                return Token.OPEN_VECTOR;
            } else if ('#' == cin && ('t' == peek || 'f' == peek)) {
                m_reader.getc();
                return Token.BOOL;
            } else if ('#' == cin && '\\' == peek) {
                m_reader.getc();

                StringBuilder sb = new StringBuilder();
                peek = m_reader.peek();

                if (char.IsLetter(peek)) {
                    do {
                        sb.Append(char.ConvertFromUtf32(m_reader.getc()));
                        peek = m_reader.peek();
                    } while (peek != -1 && !is_delimiter(peek));
                } else if (-1 == peek) {
                    return Token.ERROR;
                } else {
                    sb.Append(char.ConvertToUtf32(peek));
                    m_reader.getc();
                }

                return Token.CHAR;
            } else if ('"' == cin) {
                StringBuilder sb = new StringBuilder();
                int peek = m_reader.peek();

                while (peek != '"') {
                    if (-1 == peek) {
                        return Token.ERROR;
                    }

                    if ('\\' == peek) {
                        m_reader.getc();
                        peek = m_reader.peek();

                        if (peek != '\\' && peek != '"') {
                            // WARNING!
                        }
                    }

                    sb.Append(char.ConvertFromUtf32(m_reader.getc()));
                    peek = m_reader.peek();
                }

                m_reader.getc();

                return Token.STRING;
            } else if ('(' == cin) {
                return Token.OPEN_PAREN;
            } else if (')' == cin) {
                return Token.CLOSE_PAREN;
            } else if ('`' == cin) {
                return Token.LEFT_QUOTE;
            } else if ('\'' == cin) {
                return Token.RIGHT_QUOTE;
            } else if (',' == cin) {
                if ('@' == m_reader.peek()) {
                    m_reader.getc();
                    return Token.SPLICING_UNQUOTE;
                } else {
                    return Token.COMMA;
                }
            } else if ('.' == cin) {
                if ('.' == m_reader.peek()) {
                    m_reader.getc();
                    if ('.' == m_reader.peek()) {
                        m_reader.getc();
                        return m_simple ? Token.ID : Token.VAR;
                    } else {
                        return Token.ERROR;
                    }
                } else {
                    return Token.DOT;
                }
            } else {
                return Token.ERROR;
            }
        }






        private bool is_initial(int cin)
        {
            return
                char.IsLetter((char)cin) ||
                '!' == cin ||
                '$' == cin ||
                '%' == cin ||
                '&' == cin ||
                '*' == cin ||
                '/' == cin ||
                ':' == cin ||
                '<' == cin ||
                '=' == cin ||
                '>' == cin ||
                '?' == cin ||
                '^' == cin ||
                '_' == cin ||
                '~' == cin;
        }

        private bool is_subsequent(int cin)
        {
            return
                is_initial(cin) ||
                char.IsDigit((char)cin) ||
                '+' == cin ||
                '-' == cin ||
                '.' == cin ||
                '@' == cin;
        }




        public enum Token {
            ERROR,
            EOF,
            VAR,
            BOOL,
            NUM,
            CHAR,
            STRING,
            OPEN_PAREN,
            CLOSE_PAREN,
            OPEN_VECTOR,
            LEFT_QUOTE,
            RIGHT_QUOTE,
            COMMA,
            SPLICING_UNQUOTE,
            DOT,
            _FIRST_EXPRESSION_KW,
            KW_QUOTE,
            KW_LAMBDA,
            KW_IF,
            KW_SET,
            KW_BEGIN,
            KW_COND,
            KW_AND,
            KW_OR,
            KW_CASE,
            KW_LET,
            KW_LET_STAR,
            KW_LETREC,
            KW_DO,
            KW_DELAY,
            _LAST_EXPRESSION_KW,
            _FIRST_SYNTAX_KW,
            KW_QUASIQUOTE,
            KW_ELSE,
            KW_GOES_TO,
            KW_DEFINE,
            KW_UNQUOTE,
            KW_UNQUOTE_SPLICING,
            _LAST_SYNTAX_KW,
        }





        void expression_list()
        {
            while (lookahead != Token.EOF) {
                expression();
            }
        }

        void expression()
        {
            if (Token.ID == lookahead) {
                variable();
            } else if (Token.ID == lookahead) {
                literal();
            } else if (Token.ID == lookahead) {
                procedure_call();
            } else if (Token.ID == lookahead) {
                lamda_expression();
            } else if (Token.ID == lookahead) {
                conditional();
            } else if (Token.ID == lookahead) {
                assignment();
            } else if (Token.ID == lookahead) {
                derived_expression();
            } else if (Token.ID == lookahead) {
                macro_use();
            } else if (Token.ID == lookahead) {
                macro_block();
            }
        }




    public class VectorVisitor {
        public void visit()
        {
        }

        public void visitEnd()
        {
        }

        public void visitItem(Boolean o)
        {
        }

        public void visitItem(Char o)
        {
        }

        public void visitItem(Int64 o)
        {
        }

        public void visitItem(Double o)
        {
        }

        public void visitItem(String o)
        {
        }

        public SymbolVisitor visitItem_Symbol()
        {
            return null;
        }

        public VectorVisitor visitItem_Vector()
        {
            return null;
        }

        public Visitor visitItem_Cons()
        {
            return null;
        }
    }





using System;

namespace CodeBuilder {
    class TypePirateBuilder : TypeVisitor {
        public override void visit_name(string name) { }
    }

    class TypeListPirateBuilder : TypeListVisitor {
        public override TypeVisitor visitItem_Type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visitItem_Prototype() { return new PrototypePirateBuilder(); }
    }

    class PrototypePirateBuilder : PrototypeVisitor {
        public override void visit_name(string name) { }
        public override TypeListVisitor visit_parameter_types() { return new TypeListPirateBuilder(); }
        public override TypeListVisitor visit_return_types() { return new TypeListPirateBuilder(); }
    }

    class PrototypeListPirateBuilder : PrototypeListVisitor {
        public override PrototypeVisitor visitItem() { return new PrototypePirateBuilder(); }
    }

    class OperandPirateBuilder : OperandVisitor {
        public override TypeVisitor visit_Type_type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visit_Prototype_type() { return new PrototypePirateBuilder(); }
        public override void visit_name(string name) { }
    }

    class LvalueListPirateBuilder : LvalueListVisitor {
        public override GlobalVisitor visitItem_Global() { return new GlobalPirateBuilder(); }
        public override LocalVisitor visitItem_Local() { return new LocalPirateBuilder(); }
        public override ParameterVisitor visitItem_Parameter() { return new ParameterPirateBuilder(); }
    }

    class OperandListPirateBuilder : OperandListVisitor {
        public override GlobalVisitor visitItem_Global() { return new GlobalPirateBuilder(); }
        public override LocalVisitor visitItem_Local() { return new LocalPirateBuilder(); }
        public override ParameterVisitor visitItem_Parameter() { return new ParameterPirateBuilder(); }
        public override ConstantVisitor visitItem_Constant() { return new ConstantPirateBuilder(); }
    }

    class GlobalPirateBuilder : GlobalVisitor {
        public override TypeVisitor visit_Type_type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visit_Prototype_type() { return new PrototypePirateBuilder(); }
        public override void visit_name(string name) { }
    }

    class GlobalListPirateBuilder : GlobalListVisitor {
        public override GlobalVisitor visitItem() { return new GlobalPirateBuilder(); }
    }

    class LocalPirateBuilder : LocalVisitor {
        public override TypeVisitor visit_Type_type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visit_Prototype_type() { return new PrototypePirateBuilder(); }
        public override void visit_name(string name) { }
    }

    class LocalListPirateBuilder : LocalListVisitor {
        public override LocalVisitor visitItem() { return new LocalPirateBuilder(); }
    }

    class ParameterPirateBuilder : ParameterVisitor {
        public override TypeVisitor visit_Type_type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visit_Prototype_type() { return new PrototypePirateBuilder(); }
        public override void visit_name(string name) { }
    }

    class ParameterListPirateBuilder : ParameterListVisitor {
        public override ParameterVisitor visitItem() { return new ParameterPirateBuilder(); }
    }

    class ConstantPirateBuilder : ConstantVisitor {
        public override TypeVisitor visit_Type_type() { return new TypePirateBuilder(); }
        public override PrototypeVisitor visit_Prototype_type() { return new PrototypePirateBuilder(); }
        public override void visit_name(string name) { }
    }

    class ConstantListPirateBuilder : ConstantListVisitor {
        public override ConstantVisitor visitItem() { return new ConstantPirateBuilder(); }
    }

    class OperatorPirateBuilder : OperatorVisitor {
        public override void visit_name(string name) { }
        public override TypeListVisitor visit_result_types() { return new TypeListPirateBuilder(); }
        public override TypeListVisitor visit_operand_types() { return new TypeListPirateBuilder(); }
    }

    class OperatorListPirateBuilder : OperatorListVisitor {
        public override OperatorVisitor visitItem() { return new OperatorPirateBuilder(); }
    }

    class LambdaPirateBuilder : LambdaVisitor {
        public override void visit_name(string name) { }
        public override TypeListVisitor visit_return_types() { return new TypeListPirateBuilder(); }
        public override ParameterListVisitor visit_parameter_types() { return new ParameterListPirateBuilder(); }
        public override LocalListVisitor visit_locals() { return new LocalListPirateBuilder(); }
        public override LambdaListVisitor visit_lambda() { return new LambdaListPirateBuilder(); }
        public override StatementListVisitor visit_statements() { return new StatementListPirateBuilder(); }
    }

    class LambdaListPirateBuilder : LambdaListVisitor {
        public override LambdaVisitor visitItem() { return new LambdaPirateBuilder(); }
    }

    class StatementListPirateBuilder : StatementListVisitor {
        public override OperatorStampVisitor visitItem_OperatorStamp() { return new OperatorStampPirateBuilder(); }
        public override LambdaStampVisitor visitItem_LambdaStamp() { return new LambdaStampPirateBuilder(); }
        public override CallVisitor visitItem_Call() { return new CallPirateBuilder(); }
        public override IfVisitor visitItem_If() { return new IfPirateBuilder(); }
        public override MoveVisitor visitItem_Move() { return new MovePirateBuilder(); }
    }

    class OperatorStampPirateBuilder : OperatorStampVisitor {
        public override void visit_label(string label) { }
        public override LvalueListVisitor visit_lvalues() { return new LvalueListPirateBuilder(); }
        public override OperatorVisitor visit_op() { return new OperatorPirateBuilder(); }
        public override OperandListVisitor visit_arguments() { return new OperandListPirateBuilder(); }
    }

    class LambdaStampPirateBuilder : LambdaStampVisitor {
        public override void visit_label(string label) { }
        public override LvalueListVisitor visit_lvalues() { return new LvalueListPirateBuilder(); }
        public override LambdaVisitor visit_lambda() { return new LambdaPirateBuilder(); }
        public override OperandListVisitor visit_arguments() { return new OperandListPirateBuilder(); }
    }

    class CallPirateBuilder : CallVisitor {
        public override void visit_label(string label) { }
        public override LvalueListVisitor visit_lvalues() { return new LvalueListPirateBuilder(); }
        public override PrototypeVisitor visit_prototype() { return new PrototypePirateBuilder(); }
        public override GlobalVisitor visit_Global_lambda_ref() { return new GlobalPirateBuilder(); }
        public override LocalVisitor visit_Local_lambda_ref() { return new LocalPirateBuilder(); }
        public override ParameterVisitor visit_Parameter_lambda_ref() { return new ParameterPirateBuilder(); }
        public override ConstantVisitor visit_Constant_lambda_ref() { return new ConstantPirateBuilder(); }
        public override OperandListVisitor visit_arguments() { return new OperandListPirateBuilder(); }
    }

    class RelationPirateBuilder : RelationVisitor {
        public override void visit_name(string name) { }
        public override TypeListVisitor visit_element_types() { return new TypeListPirateBuilder(); }
    }

    class RelationListPirateBuilder : RelationListVisitor {
        public override RelationVisitor visitItem() { return new RelationPirateBuilder(); }
    }

    class IfPirateBuilder : IfVisitor {
        public override void visit_label(string label) { }
        public override LvalueListVisitor visit_lvalues() { return new LvalueListPirateBuilder(); }
        public override RelationVisitor visit_conditional() { return new RelationPirateBuilder(); }
        public override LambdaVisitor visit_consequent() { return new LambdaPirateBuilder(); }
        public override LambdaVisitor visit_alternate() { return new LambdaPirateBuilder(); }
    }

    class MovePirateBuilder : MoveVisitor {
        public override void visit_label(string label) { }
        public override LvalueListVisitor visit_lvalues() { return new LvalueListPirateBuilder(); }
        public override OperandListVisitor visit_rvalues() { return new OperandListPirateBuilder(); }
    }

    class PirateCodeBuilder : CodeVisitor {
        public override TypeListVisitor visit_types() { return new TypeListPirateBuilder(); }
        public override ConstantListVisitor visit_constants() { return new ConstantListPirateBuilder(); }
        public override GlobalListVisitor visit_globals() { return new GlobalListPirateBuilder(); }
        public override OperatorListVisitor visit_operators() { return new OperatorListPirateBuilder(); }
        public override PrototypeListVisitor visit_prototypes() { return new PrototypeListPirateBuilder(); }
        public override RelationListVisitor visit_relations() { return new RelationListPirateBuilder(); }
        public override LambdaListVisitor visit_lambdas() { return new LambdaListPirateBuilder(); }
    }
}









        public override void visit_value(Boolean o)
        {
            Console.WriteLine("bool {0} ", Literal.literal(o));
        }

        public override void visit_value(Char o)
        {
            Console.WriteLine("char {0} ", Literal.literal(o));
        }

        public override void visit_value(Int64 o)
        {
            Console.WriteLine("int {0} ", Literal.literal(o));
        }

        public override void visit_value(Double o)
        {
            Console.WriteLine("double {0} ", Literal.literal(o));
        }

        public override void visit_value(String o)
        {
            Console.WriteLine("string {0} ", Literal.literal(o));
        }

        public override void visit_value(Symbol o)
        {
            Console.WriteLine("symbol {0} ", Literal.literal(o));
        }

        //public override void visit_value(object o)
        //{
        //    Console.WriteLine("{0} {1} ", o.GetType().FullName, o.ToString());
        //}







            
            //Pair rv = null;

            //if (args.Count > 0) {
            //    Pair current = new Pair();
            //    current.head = args[0];
            //    current.tail = null;

            //    args.RemoveAt(0);

            //    rv = current;

            //    foreach (object o in args) {
            //        current.tail = new Pair();

            //        current = (Pair)current.tail;

            //        current.head = o;
            //        current.tail = null;
            //    }
            //}

            //return rv;



        List<string> m_keywords;

        public Scanner(Reader reader)
            : this(reader, null)
        { }

        public Scanner(Reader reader, List<string> keywords)
        {
            m_reader = reader;
            m_keywords = keywords;
        }
        static List<string> default_keywords()
        {
            List<string> kw = new List<string>();

            kw.Add("access");
            kw.Add("and");
            kw.Add("begin");
            kw.Add("case");
            kw.Add("cond");
            kw.Add("cons-stream");
            kw.Add("declare");
            kw.Add("default-object?");
            kw.Add("define");
            kw.Add("define-integrable");
            kw.Add("define-structure");
            kw.Add("define-syntax");
            kw.Add("delay");
            kw.Add("do");
            kw.Add("er-macro-transformer");
            kw.Add("fluid-let");
            kw.Add("if");
            kw.Add("lambda");
            kw.Add("let");
            kw.Add("let*");
            kw.Add("let*-syntax");
            kw.Add("let-syntax");
            kw.Add("letrec");
            kw.Add("letrec-syntax");
            kw.Add("local-declare");
            kw.Add("named-lambda");
            kw.Add("non-hygienic-macro-transformer");
            kw.Add("or");
            kw.Add("quasiquote");
            kw.Add("quote");
            kw.Add("rsc-macro-transformer");
            kw.Add("sc-macro-transformer");
            kw.Add("set!");
            kw.Add("syntax-rules");
            kw.Add("the-environment");

            return kw;
        }

        bool is_keyword(string keyword)
        {
            if (m_keywords != null) {
                return m_keywords.Contains(keyword);
            } else {
                return false;
            }
        }

        KEYWORD,

                } else if (is_keyword(attrib.literal)) {
                    attrib.value = attrib.literal;
                    attrib.token = Token.KEYWORD;


            {
                bool first = true;
                foreach (string s in list)
                {
                    if (!first) Append(delim);

                    Append(s);

                    if (first) first = false;
                }
            }

            return this;
        }



        //public override void visit_value(Boolean o)
        //{
        //    m_args.Add(o);
        //}

        //public override void visit_value(Int64 o)
        //{
        //    m_args.Add(o);
        //}

        //public override void visit_value(Double o)
        //{
        //    m_args.Add(o);
        //}

        //public override void visit_value(Char o)
        //{
        //    m_args.Add(o);
        //}

        //public override void visit_value(String o)
        //{
        //    m_args.Add(o);
        //}

        //public override void visit_value(Symbol o)
        //{
        //    m_args.Add(o);
        //}




        //public override void visit_value(Boolean v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}

        //public override void visit_value(Int64 v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}

        //public override void visit_value(Double v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}

        //public override void visit_value(Char v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}

        //public override void visit_value(String v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}

        //public override void visit_value(Symbol v)
        //{
        //    m_literal = Literal.literal(v);
        //    value = v;
        //}


        public override void visit_car()
        {
            car = null;
        }

        public override void visit_cdr()
        {
            cdr = null;
        }



        public override void visit_car()
        { }

        public override void visit_cdr()
        { }


            //Monad2<List<object>> m_args2;
            //Monad2<object[]> m_vect2;
            //Monad2<object[]>.Fn fn = delegate(object[] o1) { m_args2.bind(delegate(List<object> o2) { o2.Add(o1); return m_args2; }); return m_vect2; };
            //m_vect2.bind(fn);
            
            
                public class Monad2<T> {
        public Monad2(T o)
        {
        }

        public delegate Monad2<T> Fn(T o);

        public Monad2<T> bind(Fn fn)
        {
            return null;
        }
    }



    public interface ObjectCell {
        object value { get; }
        void bind(object o);
    }

    public abstract class Cell<T> : ObjectCell {
        T m_contents;

        T value 
        { 
            get { return m_contents; }
            set { m_contents = value; }
        }

        delegate void Fn(T o);

        public void bind(Fn o)
        {

        }

        #region ObjectCell Members

        object ObjectCell.value
        {
            get { return m_value; }
        }

        #endregion
    }



    public class SuperVectorWriter : VectorVisitor {
        Writer m_writer;
        string m_delim;
        string m_eol;

        public SuperVectorWriter(Writer writer, string delim, string eol)
        {
            m_writer = writer;
            m_delim = delim;
            m_eol = eol;
        }

        public override AtomVisitor visitItem_Atom()
        {
            return new TopAtomWriter(m_writer, m_delim, m_eol);
        }

        public override ConsVisitor visitItem_Cons()
        {
            return new TopConsWriter(m_writer, m_delim, m_eol);
        }

        public override VectorVisitor visitItem_Vector()
        {
            return new TopVectorWriter(m_writer);
        }

        public override void visitItem()
        {
            m_writer.Append("()").Append(m_eol);
        }
    }

    public class SuperConsWriter : ConsVisitor {
    }

    public class SuperAtomWriter : AtomWriter {
    }






    public static class MakeConfig {
        public static SexpWriterConfig make_basic_config(Writer writer)
        {
            SexpWriterConfig rv = new SexpWriterConfig();

            SexpWriter top = new SexpWriter(writer, rv);
            top.abbreviate = true;
            top.indent = false;
            top.head = "";
            top.headline = 0;
            top.sep = "";
            top.sepline = 2;
            top.foot = "";
            top.footline = 1;

            SexpWriter cons = new SexpWriter(writer, rv);
            //cons.abbreviate = true;
            cons.indent = true;
            cons.head = "(";
            //cons.headline = 0;
            //cons.sep = "";
            //cons.sepline = 0;
            cons.foot = ")";
            cons.footline = 0;

            SexpWriter first_car_cons = new SexpWriter(writer, rv);
            //first_car_cons.abbreviate = true;
            first_car_cons.indent = false;
            first_car_cons.head = "(";
            first_car_cons.headline = 0;
            //first_car_cons.sep = "";
            //first_car_cons.sepline = 0;
            first_car_cons.foot = ")";
            first_car_cons.footline = 0;

            SexpWriter first_cdr_cons = new SexpWriter(writer, rv);
            //first_cdr_cons.abbreviate = true;
            first_cdr_cons.indent = false;
            first_cdr_cons.head = " ";
            first_cdr_cons.headline = 0;
            //first_cdr_cons.sep = "";
            //first_cdr_cons.sepline = 0;
            first_cdr_cons.foot = "";
            first_cdr_cons.footline = 0;

            SexpWriter cdr_cons = new SexpWriter(writer, rv);
            //cdr_cons.abbreviate = true;
            cdr_cons.indent = false;
            cdr_cons.head = "";
            cdr_cons.headline = 1;
            //cdr_cons.sep = "";
            //cdr_cons.sepline = 0;
            cdr_cons.foot = "";
            cdr_cons.footline = 0;

            SexpWriter top_vect = new SexpWriter(writer, rv);
            //top_vect.abbreviate = true;
            top_vect.indent = false;
            top_vect.head = "#(";
            top_vect.headline = 0;
            top_vect.sep = " ";
            top_vect.sepline = 0;
            top_vect.foot = ")";
            top_vect.footline = 1;

            SexpWriter vect = new SexpWriter(writer, rv);
            //vect.abbreviate = true;
            vect.indent = false;
            vect.head = " #(";
            vect.headline = 1;
            vect.sep = " ";
            vect.sepline = 0;
            vect.foot = ")";
            vect.footline = 0;

            SexpWriter cdr_vect = new SexpWriter(writer, rv);
            //cdr_vect.abbreviate = true;
            cdr_vect.indent = false;
            cdr_vect.head = " . #(";
            cdr_vect.headline = 0;
            cdr_vect.sep = " ";
            cdr_vect.sepline = 0;
            cdr_vect.foot = ")";
            cdr_vect.footline = 0;

            SexpWriter atom = new SexpWriter(writer, rv);
            //atom.abbreviate = true;
            atom.indent = false;
            atom.head = "";
            atom.headline = 0;
            //atom.sep = " ";
            //atom.sepline = 0;
            atom.foot = "";
            atom.footline = 0;

            SexpWriter cdr_atom = new SexpWriter(writer, rv);
            //cdr_atom.abbreviate = true;
            cdr_atom.indent = false;
            cdr_atom.head = " . ";
            cdr_atom.headline = 0;
            //cdr_atom.sep = " ";
            //cdr_atom.sepline = 0;
            cdr_atom.foot = "";
            cdr_atom.footline = 0;

            SexpWriter quote_cons = new SexpWriter(writer, rv);
            //quote_cons.abbreviate = true;
            quote_cons.indent = false;
            quote_cons.head = " ";
            //quote_cons.headline = 0;
            //quote_cons.sep = "";
            //quote_cons.sepline = 0;
            quote_cons.foot = "";
            quote_cons.footline = 0;

            SexpWriter quote_vect = new SexpWriter(writer, rv);
            //quote_vect.abbreviate = true;
            quote_vect.indent = false;
            quote_vect.head = "#(";
            quote_vect.headline = 0;
            quote_vect.sep = " ";
            quote_vect.sepline = 0;
            quote_vect.foot = ")";
            quote_vect.footline = 0;

            rv.top = top;
            rv.top_vect = top_vect;
            rv.top_cons = cons;
            rv.top_atom = atom;
            rv.car_vect = vect;
            rv.car_cons = cons;
            rv.car_atom = atom;
            rv.cdr_cons = cdr_cons;
            rv.cdr_vect = cdr_vect;
            rv.cdr_atom = cdr_atom;
            rv.quote_cons = quote_cons;
            rv.quote_vect = quote_vect;
            rv.quote_atom = atom;
            rv.item_vect = vect;
            rv.item_cons = cons;
            rv.item_atom = atom;
            rv.car_item_vect = vect;
            rv.car_item_cons = cons;
            rv.car_item_atom = atom;
            rv.cdr_item_vect = cdr_vect;
            rv.cdr_item_cons = cdr_cons;
            rv.cdr_item_atom = cdr_atom;
            rv.first_car_cons = first_car_cons;
            rv.first_cdr_cons = first_cdr_cons;
            return rv;
        }
    }

    public enum State {
        TOP,
        TOP_VECT,
        CAR_VECT,
        CDR_VECT,
        ITEM_VECT,
        TOP_CONS,
        CAR_CONS,
        CDR_CONS,
        ITEM_CONS,
        QUOTE_CONS,
        QUOTE_ATOM,
        QUOTE_VECT,
        CAR_ATOM,
        TOP_ATOM,
        ITEM_ATOM,
        ABBREV,
        CDR_ITEM_VECT,
        CDR_ITEM_CONS,
        CDR_ITEM_ATOM,
        CDR_ATOM,
        CAR_ITEM_VECT,
        CAR_ITEM_CONS,
        CAR_ITEM_ATOM,
        FIRST_CAR_CONS,
        FIRST_CDR_CONS,
        COUNT
    }

    public class SexpWriter {
        public bool? abbreviate;
        public bool? indent;
        public string head;
        public int? headline;
        public string sep;
        public int? sepline;
        public string foot;
        public int? footline;

        Writer m_writer;

        SexpWriterConfig m_cfg;

        public SexpWriter(Writer writer, SexpWriterConfig cfg)
        {
            m_writer = writer;
            m_cfg = cfg;
        }

        SexpWriter cascade(SexpWriter next_cfg)
        {
            SexpWriter new_cfg = new SexpWriter(m_writer, m_cfg);

            new_cfg.abbreviate = next_cfg.abbreviate ?? this.abbreviate;
            new_cfg.indent = next_cfg.indent ?? this.indent;
            new_cfg.head = next_cfg.head ?? this.head;
            new_cfg.headline = next_cfg.headline ?? this.headline;
            new_cfg.sep = next_cfg.sep ?? this.sep;
            new_cfg.sepline = next_cfg.sepline ?? this.sepline;
            new_cfg.foot = next_cfg.foot ?? this.foot;
            new_cfg.footline = next_cfg.footline ?? this.footline;

            return new_cfg;
        }

        public VectorWriter nextItemVectorWriter(State s)
        {
            if (State.TOP == s) {
                return new VectorWriter(m_cfg.top_vect, State.TOP_VECT);
            } else if (
                State.TOP_VECT == s ||
                State.ITEM_VECT == s ||
                State.CAR_VECT == s ||
                State.CAR_ITEM_VECT == s ||
                State.CDR_VECT == s ||
                State.CDR_ITEM_VECT == s ||
                State.QUOTE_VECT == s) {

                return new VectorWriter(m_cfg.item_vect, State.ITEM_VECT);
            } else {
                throw new Exception();
            }
        }

        public ConsWriter nextItemConsWriter(State s)
        {
            if (State.TOP == s) {
                return new ConsWriter(cascade(m_cfg.top_cons), State.TOP_CONS);
            } else if (
                State.TOP_VECT == s ||
                State.ITEM_VECT == s ||
                State.CAR_VECT == s ||
                State.CAR_ITEM_VECT == s ||
                State.CDR_VECT == s ||
                State.CDR_ITEM_VECT == s ||
                State.QUOTE_VECT == s) {

                return new ConsWriter(cascade(m_cfg.item_cons), State.ITEM_CONS);
            } else {
                throw new Exception();
            }
        }

        public AtomWriter nextItemAtomWriter(State s)
        {
            if (State.TOP == s) {
                return new AtomWriter(cascade(m_cfg.top_atom), State.TOP_ATOM);
            } else if (
                State.TOP_VECT == s ||
                State.ITEM_VECT == s ||
                State.CAR_VECT == s ||
                State.CAR_ITEM_VECT == s ||
                State.CDR_VECT == s ||
                State.CDR_ITEM_VECT == s ||
                State.QUOTE_VECT == s) {

                return new AtomWriter(cascade(m_cfg.item_atom), State.ITEM_ATOM);
            } else {
                throw new Exception();
            }
        }

        public VectorWriter nextCarVectorWriter(State s)
        {
            if (State.QUOTE_CONS == s) {
                return new VectorWriter(cascade(m_cfg.quote_vect), State.QUOTE_VECT);
            } else if (State.ITEM_CONS == s) {
                return new VectorWriter(cascade(m_cfg.item_vect), State.ITEM_VECT);
            } else if (State.TOP_CONS == s || State.FIRST_CAR_CONS == s || State.FIRST_CDR_CONS == s || State.CAR_CONS == s || State.CDR_CONS == s) {
                return new VectorWriter(cascade(m_cfg.car_vect), State.CAR_VECT);
            } else {
                throw new Exception();
            }
        }

        public ConsWriter nextCarConsWriter(State s)
        {
            if (State.ITEM_CONS == s) {
                return new ConsWriter(cascade(m_cfg.item_cons), State.ITEM_CONS);
            } else if (State.TOP_CONS == s || State.CAR_CONS == s || State.FIRST_CAR_CONS == s || State.FIRST_CDR_CONS == s) {
                return new ConsWriter(cascade(m_cfg.first_car_cons), State.FIRST_CAR_CONS);
            } else if (State.CDR_CONS == s || State.QUOTE_CONS == s) {
                return new ConsWriter(cascade(m_cfg.car_cons), State.CAR_CONS);
            } else {
                throw new Exception();
            }
        }

        public AtomVisitor nextCarAtomWriter(State s, out AtomCtor atom)
        {
            //if (abbreviate) {
            atom = new AtomCtor();
            return new AtomBuilder(atom);
            //} else {
            //if (State.ABBREV == s) {
            //    return new AtomWriter(cascade(m_cfg.quote_atom), State.QUOTE_ATOM);
            //} else if (State.ITEM_CONS == s) {
            //    return new AtomWriter(cascade(m_cfg.item_atom), State.ITEM_ATOM);
            //} else if (State.TOP_CONS == s || State.CAR_CONS == s || State.CDR_CONS == s || State.QUOTE_CONS == s) {
            //    return new AtomWriter(cascade(m_cfg.car_atom), State.CAR_ATOM);
            //} else {
            //    throw new Exception();
            //}
            //}
        }

        public VectorWriter nextCdrVectorWriter(State s)
        {
            if (State.ITEM_CONS == s) {
                return new VectorWriter(cascade(m_cfg.cdr_item_vect), State.CDR_ITEM_VECT);
            } else if (State.TOP_CONS == s || State.FIRST_CAR_CONS == s || State.FIRST_CDR_CONS == s || State.CAR_CONS == s || State.CDR_CONS == s) {
                return new VectorWriter(cascade(m_cfg.cdr_vect), State.CDR_VECT);
            } else {
                throw new Exception();
            }
        }

        public ConsWriter nextCdrConsWriter(State s)
        {
            if (State.ABBREV == s) {
                return new ConsWriter(cascade(m_cfg.quote_cons), State.QUOTE_CONS);
            } else if (State.ITEM_CONS == s) {
                return new ConsWriter(cascade(m_cfg.cdr_item_cons), State.CDR_ITEM_CONS);
            } else if (State.FIRST_CAR_CONS == s|| State.FIRST_CDR_CONS == s) {
                return new ConsWriter(cascade(m_cfg.first_cdr_cons), State.FIRST_CDR_CONS);
            } else if (State.TOP_CONS == s || State.CAR_CONS == s || State.CDR_CONS == s || State.QUOTE_CONS == s) {
                return new ConsWriter(cascade(m_cfg.cdr_cons), State.CDR_CONS);
            } else {
                throw new Exception();
            }
        }

        public AtomWriter nextCdrAtomWriter(State s)
        {
            if (State.ITEM_CONS == s) {
                return new AtomWriter(cascade(m_cfg.cdr_item_atom), State.CDR_ITEM_ATOM);
            } else if (State.TOP_CONS == s || State.CAR_CONS == s || State.CDR_CONS == s || State.QUOTE_CONS == s || State.FIRST_CAR_CONS == s || State.FIRST_CDR_CONS == s) {
                return new AtomWriter(cascade(m_cfg.cdr_atom), State.CDR_ATOM);
            } else {
                throw new Exception();
            }
        }

        public SexpWriter Append(string s)
        {
            m_writer.Append(s);
            return this;
        }

        void lines(int c)
        {
            for (int i = 0; i < c; i++) {
                m_writer.End();
            }

            if (c > 0) m_writer.Begin();
        }

        public SexpWriter Head()
        {
            m_writer.Append(head ?? "");
            lines(headline ?? 0);

            if (indent ?? false) m_writer.Indent();

            return this;
        }

        public SexpWriter Delimiter(ref bool is_first)
        {
            if (is_first) {
                is_first = false;
            } else {
                m_writer.Append(sep ?? " ");
                lines(sepline ?? 0);
            }

            return this;
        }

        public SexpWriter Foot()
        {
            if (indent ?? false) m_writer.Unindent();

            m_writer.Append(foot ?? "");
            lines(footline ?? 0);

            return this;
        }

        public SexpWriter Car(AtomCtor atom)
        {
            if (atom != null) {
                return Head().Append(Literal.literal(atom.value));
            }

            return this;
        }

        public SexpWriter Abbrev(AtomCtor atom, out bool is_quote)
        {
            if (abbreviate ?? false) {
                if (atom != null && atom.value is Symbol) {
                    if (((Symbol)atom.value).name == "quote") {
                        m_writer.Append("'");
                        is_quote = true;
                        return this;
                    } else if (((Symbol)atom.value).name == "quasiquotation") {
                        m_writer.Append("`");
                        is_quote = true;
                        return this;
                    } else if (((Symbol)atom.value).name == "unquote") {
                        m_writer.Append(",");
                        is_quote = true;
                        return this;
                    } else if (((Symbol)atom.value).name == "unquote-splicing") {
                        m_writer.Append(",@");
                        is_quote = true;
                        return this;
                    }
                }
            }

            is_quote = false;
            return Car(atom);
        }
    }
